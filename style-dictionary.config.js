/**
 * Style Dictionary Configuration
 * Generates theme-aware CSS with proper selectors
 */

import StyleDictionary from 'style-dictionary';

// Custom format: generates theme CSS with data-theme selectors
StyleDictionary.registerFormat({
  name: 'css/themes',
  format: ({ dictionary, options }) => {
    const themes = {};
    const baseTokens = [];

    // Separate theme tokens from base tokens
    dictionary.allTokens.forEach(token => {
      if (token.path[0] === 'theme') {
        // Theme token: theme.{themeName}.{mode}.{category}.{name}
        const [, themeName, mode, ...rest] = token.path;
        const key = `${themeName}-${mode}`;
        if (!themes[key]) {
          themes[key] = { themeName, mode, tokens: [] };
        }
        themes[key].tokens.push({
          name: rest.join('-'),
          value: token.value
        });
      } else {
        // Base token (spacing, shadow, etc.)
        baseTokens.push(token);
      }
    });

    let output = `/**
 * Design Tokens - Auto-generated by Style Dictionary
 * Do not edit directly
 */

/* ============================================
   Base Tokens (spacing, shadows, typography, etc.)
   ============================================ */
:root {
`;

    // Output base tokens
    baseTokens.forEach(token => {
      const name = token.path.join('-');
      output += `  --${name}: ${token.value};\n`;
    });

    output += `}

/* ============================================
   Theme Tokens
   ============================================ */
`;

    // Output theme tokens with proper selectors
    Object.entries(themes).forEach(([key, { themeName, mode, tokens }]) => {
      // Map variable names to match existing global.css convention
      const varMapping = {
        'bg-primary': 'bg-primary',
        'bg-secondary': 'bg-secondary',
        'bg-tertiary': 'bg-tertiary',
        'bg-highlight': 'bg-highlight',
        'fg-primary': 'fg-primary',
        'fg-secondary': 'fg-secondary',
        'fg-muted': 'fg-muted',
        'fg-dark': 'fg-dark',
        'accent-blue': 'accent-blue',
        'accent-cyan': 'accent-cyan',
        'accent-purple': 'accent-purple',
        'accent-green': 'accent-green',
        'accent-orange': 'accent-orange',
        'accent-red': 'accent-red',
        'accent-yellow': 'accent-yellow',
        'border': 'border-color',
        'scrollbar-track': 'scrollbar-track',
        'scrollbar-thumb': 'scrollbar-thumb',
        'editor-bg': 'editor-bg',
        'editor-line-highlight': 'editor-line-highlight',
        'editor-selection': 'editor-selection',
        'editor-cursor': 'editor-cursor',
        'md-heading1': 'md-heading1',
        'md-heading2': 'md-heading2',
        'md-heading3': 'md-heading3',
        'md-heading4': 'md-heading4',
        'md-heading5': 'md-heading5',
        'md-bold': 'md-bold',
        'md-italic': 'md-italic',
        'md-link': 'md-link',
        'md-code': 'md-code',
        'md-code-bg': 'md-code-bg'
      };

      // Determine selector
      let selector;
      if (themeName === 'tokyo-night' && mode === 'dark') {
        // Default theme - applies to :root and explicit selector
        output += `:root,\n:root[data-theme="tokyo-night"][data-mode="dark"] {\n`;
      } else {
        output += `:root[data-theme="${themeName}"][data-mode="${mode}"] {\n`;
      }

      tokens.forEach(({ name, value }) => {
        const mappedName = varMapping[name] || name;
        output += `  --${mappedName}: ${value};\n`;
      });

      output += `}\n\n`;
    });

    return output;
  }
});

export default {
  source: ['tokens/**/*.json'],
  platforms: {
    css: {
      transformGroup: 'css',
      buildPath: 'src/styles/generated/',
      files: [
        {
          destination: 'tokens.css',
          format: 'css/themes'
        }
      ]
    }
  }
};
